; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: %riscv32_cheri_purecap_opt -instsimplify -cheri-bound-allocas -S < %s | FileCheck %s

target datalayout = "e-m:e-pf200:64:64:64:32-p:32:32-i64:64-n32-S128-A200-P200-G200"

declare ptr addrspace(200) @llvm.cheri.cap.bounds.set.i32(ptr addrspace(200), i32) addrspace(200)
declare void @use(ptr addrspace(200)) addrspace(200)

;; Check that overflowing a signed pointer index width offset (here, 32-bit)
;; with offset + size is correctly handled rather than regarding the store as
;; in bounds due to the final byte not exceeding the upper bound.
define void @test_store(i32 %a) addrspace(200) {
; CHECK-LABEL: @test_store(
; CHECK-NEXT:    [[TMP1:%.*]] = alloca [4 x i8], align 1, addrspace(200)
; CHECK-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i32(ptr addrspace(200) [[TMP1]], i32 4)
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr addrspace(200) [[TMP2]], i32 2147483646
; CHECK-NEXT:    store volatile i32 [[A:%.*]], ptr addrspace(200) [[TMP3]], align 2
; CHECK-NEXT:    ret void
;
  %1 = alloca [4 x i8], align 1, addrspace(200)
  %2 = bitcast ptr addrspace(200) %1 to ptr addrspace(200)
  %3 = getelementptr i8, ptr addrspace(200) %2, i32 2147483646
  %4 = bitcast ptr addrspace(200) %3 to ptr addrspace(200)
  store volatile i32 %a, ptr addrspace(200) %4, align 2
  ret void
}

;; Check that overflowing a signed pointer index width offset (here, 32-bit)
;; with offset + size is correctly handled rather than regarding the setbounds
;; as in bounds due to the final byte not exceeding the upper bound.
define void @test_setbounds(i32 %a) addrspace(200) {
; CHECK-LABEL: @test_setbounds(
; CHECK-NEXT:    [[TMP1:%.*]] = alloca [4 x i8], align 1, addrspace(200)
; CHECK-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i32(ptr addrspace(200) [[TMP1]], i32 4)
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr addrspace(200) [[TMP2]], i32 2147483646
; CHECK-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i32(ptr addrspace(200) [[TMP3]], i32 4)
; CHECK-NEXT:    call void @use(ptr addrspace(200) [[TMP4]])
; CHECK-NEXT:    ret void
;
  %1 = alloca [4 x i8], align 1, addrspace(200)
  %2 = bitcast ptr addrspace(200) %1 to ptr addrspace(200)
  %3 = getelementptr i8, ptr addrspace(200) %2, i32 2147483646
  %4 = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i32(ptr addrspace(200) %3, i32 4)
  call void @use(ptr addrspace(200) %4)
  ret void
}
