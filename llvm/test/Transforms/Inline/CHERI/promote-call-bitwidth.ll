; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes
; RUN: opt -S -passes=inline < %s | FileCheck %s
; RUN: sed -e 's/addrspace(200)/addrspace(0)/g' -e 's/-A200-P200-G200//g' %s | opt -S -passes=inline| FileCheck %s --check-prefix=HYBRID
; This test case (reduce from compiling libunwind) previously triggered an assertion in the
; inliner when trying to promote an indirect (virtual) call (inside llvm::tryPromoteCall)
; Assertion failed: (BitWidth == DL.getIndexTypeSizeInBits(getType()) && "The offset bit width does not match the DL specification."), function stripAndAccumulateConstantOffsets
target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A200-P200-G200"
target triple = "riscv64-unknown-freebsd13.0"

define void @test(ptr addrspace(200) %arg1, ptr addrspace(200) %arg2) local_unnamed_addr addrspace(200) {
; CHECK-LABEL: define {{[^@]+}}@test
; CHECK-SAME: (ptr addrspace(200) [[ARG1:%.*]], ptr addrspace(200) [[ARG2:%.*]]) local_unnamed_addr addrspace(200) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARG2]], align 16
; CHECK-NEXT:    call void [[TMP0]](ptr addrspace(200) [[ARG1]])
; CHECK-NEXT:    ret void
;
; HYBRID-LABEL: define {{[^@]+}}@test
; HYBRID-SAME: (ptr [[ARG1:%.*]], ptr [[ARG2:%.*]]) local_unnamed_addr {
; HYBRID-NEXT:  entry:
; HYBRID-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[ARG2]], align 16
; HYBRID-NEXT:    call void [[TMP0]](ptr [[ARG1]])
; HYBRID-NEXT:    ret void
;
entry:
  call void @call_fnptr(ptr addrspace(200) %arg1, ptr addrspace(200) %arg2)
  ret void
}

define internal void @call_fnptr(ptr addrspace(200) %this, ptr addrspace(200) %arg) unnamed_addr addrspace(200) align 2 {
entry:
  %0 = load ptr addrspace(200), ptr addrspace(200) %arg, align 16
  call void %0(ptr addrspace(200) %this)
  ret void
}

define void @test2(ptr addrspace(200) %this) local_unnamed_addr addrspace(200) {
; CHECK-LABEL: define {{[^@]+}}@test2
; CHECK-SAME: (ptr addrspace(200) [[THIS:%.*]]) local_unnamed_addr addrspace(200) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VTABLE_I:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[THIS]], align 16
; CHECK-NEXT:    [[FN_I:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[VTABLE_I]], align 16
; CHECK-NEXT:    call void [[FN_I]](ptr addrspace(200) [[THIS]])
; CHECK-NEXT:    ret void
;
; HYBRID-LABEL: define {{[^@]+}}@test2
; HYBRID-SAME: (ptr [[THIS:%.*]]) local_unnamed_addr {
; HYBRID-NEXT:  entry:
; HYBRID-NEXT:    [[VTABLE_I:%.*]] = load ptr, ptr [[THIS]], align 16
; HYBRID-NEXT:    [[FN_I:%.*]] = load ptr, ptr [[VTABLE_I]], align 16
; HYBRID-NEXT:    call void [[FN_I]](ptr [[THIS]])
; HYBRID-NEXT:    ret void
;
entry:
  call void @call_via_vtable(ptr addrspace(200) %this)
  ret void
}

define internal void @call_via_vtable(ptr addrspace(200) %this) unnamed_addr addrspace(200) {
entry:
  %0 = bitcast ptr addrspace(200) %this to ptr addrspace(200)
  %vtable = load ptr addrspace(200), ptr addrspace(200) %0, align 16
  %fn = load ptr addrspace(200), ptr addrspace(200) %vtable, align 16
  call void %fn(ptr addrspace(200) %this)
  ret void
}
