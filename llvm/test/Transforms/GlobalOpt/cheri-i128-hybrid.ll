; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --check-globals --include-generated-funcs
; RUN: opt -S -passes=globalopt < %s | FileCheck %s "--implicit-check-not=@bitcast"
; Test case reduced from compiling libc++ directory_iterator.cpp for hybrid CHERI:
; Assertion failed: (C->getType()->getIntegerBitWidth() <= 64)
; Check that we don't attempt to optimize stores of non-zero i128s to capabilities (but it is valid for plain pointers)
; After globalopt only the @bitcast_nonzero_i128_to_cap function should remain.
target datalayout = "eme-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128"

define internal void @bitcast_zero_i128_to_cap() {
entry:
  %alloca = alloca i128, align 16
  store i128 0, ptr %alloca, align 16
  %0 = bitcast ptr %alloca to ptr
  %1 = load ptr addrspace(200), ptr %0, align 16
  store ptr addrspace(200) %1, ptr @cap_from_bitcast_zero, align 16
  ret void
}

define internal void @bitcast_nonzero_i128_to_cap() {
entry:
  %alloca = alloca i128, align 16
  store i128 4321, ptr %alloca, align 16
  %0 = bitcast ptr %alloca to ptr
  %1 = load ptr addrspace(200), ptr %0, align 16
  store ptr addrspace(200) %1, ptr @cap_from_bitcast_nonzero, align 16
  ret void
}

define internal void @inttoptr_zero_i128_to_cap() {
entry:
  %alloca = alloca i128, align 16
  store i128 0, ptr %alloca, align 16
  %val = load i128, ptr %alloca, align 16
  %trunc = trunc i128 %val to i64
  %cast = inttoptr i64 %trunc to ptr addrspace(200)
  store ptr addrspace(200) %cast, ptr @cap_from_i128_inttoptr_zero, align 16
  ret void
}

define internal void @inttoptr_nonzero_i128_to_cap() {
entry:
  %alloca = alloca i128, align 16
  store i128 4321, ptr %alloca, align 16
  %val = load i128, ptr %alloca, align 16
  %trunc = trunc i128 %val to i64
  %cast = inttoptr i64 %trunc to ptr addrspace(200)
  store ptr addrspace(200) %cast, ptr @cap_from_i128_inttoptr_nonzero, align 16
  ret void
}

define internal void @inttoptr_zero_i64_to_cap() {
entry:
  %alloca = alloca i64, align 16
  store i64 0, ptr %alloca, align 16
  %val = load i64, ptr %alloca, align 16
  %cast = inttoptr i64 %val to ptr addrspace(200)
  store ptr addrspace(200) %cast, ptr @cap_from_i64_inttoptr_zero, align 16
  ret void
}

define internal void @inttoptr_nonzero_i64_to_cap() {
entry:
  %alloca = alloca i64, align 16
  store i64 4321, ptr %alloca, align 16
  %val = load i64, ptr %alloca, align 16
  %cast = inttoptr i64 %val to ptr addrspace(200)
  store ptr addrspace(200) %cast, ptr @cap_from_i64_inttoptr_nonzero, align 16
  ret void
}

define internal void @bitcast_zero_i64_to_ptr() {
entry:
  %alloca = alloca i64, align 8
  store i64 0, ptr %alloca, align 8
  %0 = bitcast ptr %alloca to ptr
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr @ptr_from_bitcast_zero, align 8
  ret void
}

define internal void @bitcast_nonzero_i64_to_ptr() {
entry:
  %alloca = alloca i64, align 8
  store i64 4321, ptr %alloca, align 8
  %0 = bitcast ptr %alloca to ptr
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr @ptr_from_bitcast_nonzero, align 8
  ret void
}

define internal void @inttoptr_zero_i128_to_ptr() {
entry:
  %alloca = alloca i128, align 16
  store i128 0, ptr %alloca, align 16
  %val = load i128, ptr %alloca, align 16
  %trunc = trunc i128 %val to i64
  %cast = inttoptr i64 %trunc to ptr
  store ptr %cast, ptr @ptr_from_i128_inttoptr_zero, align 16
  ret void
}

define internal void @inttoptr_nonzero_i128_to_ptr() {
entry:
  %alloca = alloca i128, align 16
  store i128 4321, ptr %alloca, align 16
  %val = load i128, ptr %alloca, align 16
  %trunc = trunc i128 %val to i64
  %cast = inttoptr i64 %trunc to ptr
  store ptr %cast, ptr @ptr_from_i128_inttoptr_nonzero, align 16
  ret void
}

define internal void @inttoptr_zero_i64_to_ptr() {
entry:
  %alloca = alloca i64, align 16
  store i64 0, ptr %alloca, align 16
  %val = load i64, ptr %alloca, align 16
  %cast = inttoptr i64 %val to ptr
  store ptr %cast, ptr @ptr_from_i64_inttoptr_zero, align 16
  ret void
}

define internal void @inttoptr_nonzero_i64_to_ptr() {
entry:
  %alloca = alloca i64, align 16
  store i64 4321, ptr %alloca, align 16
  %val = load i64, ptr %alloca, align 16
  %cast = inttoptr i64 %val to ptr
  store ptr %cast, ptr @ptr_from_i64_inttoptr_nonzero, align 16
  ret void
}

@llvm.global_ctors = appending global [12 x { i32, ptr, ptr }] [
  { i32, ptr, ptr } { i32 65535, ptr @bitcast_zero_i128_to_cap, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @bitcast_nonzero_i128_to_cap, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @inttoptr_zero_i128_to_cap, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @inttoptr_nonzero_i128_to_cap, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @inttoptr_zero_i64_to_cap, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @inttoptr_nonzero_i64_to_cap, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @bitcast_zero_i64_to_ptr, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @bitcast_nonzero_i64_to_ptr, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @inttoptr_zero_i128_to_ptr, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @inttoptr_nonzero_i128_to_ptr, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @inttoptr_zero_i64_to_ptr, ptr null },
  { i32, ptr, ptr } { i32 65535, ptr @inttoptr_nonzero_i64_to_ptr, ptr null }
]
@cap_from_bitcast_zero = dso_local global ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i32 1234)
@cap_from_bitcast_nonzero = dso_local global ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i32 1234)
@ptr_from_bitcast_zero = dso_local global ptr getelementptr (i8, ptr null, i32 1234)
@ptr_from_bitcast_nonzero = dso_local global ptr getelementptr (i8, ptr null, i32 1234)
; Note: the non-zero inttoptr can't be optimized for capabilities since we generate a DDC-relative value.
; This is not supported for globals so we have to use a global constructor to perform that operation.
@cap_from_i128_inttoptr_zero = dso_local global ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i32 1234)
@cap_from_i128_inttoptr_nonzero = dso_local global ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i32 1234)
@cap_from_i64_inttoptr_zero = dso_local global ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i32 1234)
@cap_from_i64_inttoptr_nonzero = dso_local global ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i32 1234)
@ptr_from_i128_inttoptr_zero = dso_local global ptr getelementptr (i8, ptr null, i32 1234)
@ptr_from_i128_inttoptr_nonzero = dso_local global ptr getelementptr (i8, ptr null, i32 1234)
@ptr_from_i64_inttoptr_zero = dso_local global ptr getelementptr (i8, ptr null, i32 1234)
@ptr_from_i64_inttoptr_nonzero = dso_local global ptr getelementptr (i8, ptr null, i32 1234)
;.
; CHECK: @llvm.global_ctors = appending global [3 x { i32, ptr, ptr }] [{ i32, ptr, ptr } { i32 65535, ptr @bitcast_nonzero_i128_to_cap, ptr null }, { i32, ptr, ptr } { i32 65535, ptr @inttoptr_nonzero_i128_to_cap, ptr null }, { i32, ptr, ptr } { i32 65535, ptr @inttoptr_nonzero_i64_to_cap, ptr null }]
; CHECK: @cap_from_bitcast_zero = dso_local local_unnamed_addr global ptr addrspace(200) null
; CHECK: @cap_from_bitcast_nonzero = dso_local local_unnamed_addr global ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i64 1234)
; CHECK: @ptr_from_bitcast_zero = dso_local local_unnamed_addr global ptr null
; CHECK: @ptr_from_bitcast_nonzero = dso_local local_unnamed_addr global ptr inttoptr (i64 4321 to ptr)
; CHECK: @cap_from_i128_inttoptr_zero = dso_local local_unnamed_addr global ptr addrspace(200) null
; CHECK: @cap_from_i128_inttoptr_nonzero = dso_local local_unnamed_addr global ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i64 1234)
; CHECK: @cap_from_i64_inttoptr_zero = dso_local local_unnamed_addr global ptr addrspace(200) null
; CHECK: @cap_from_i64_inttoptr_nonzero = dso_local local_unnamed_addr global ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i64 1234)
; CHECK: @ptr_from_i128_inttoptr_zero = dso_local local_unnamed_addr global ptr null
; CHECK: @ptr_from_i128_inttoptr_nonzero = dso_local local_unnamed_addr global ptr inttoptr (i64 4321 to ptr)
; CHECK: @ptr_from_i64_inttoptr_zero = dso_local local_unnamed_addr global ptr null
; CHECK: @ptr_from_i64_inttoptr_nonzero = dso_local local_unnamed_addr global ptr inttoptr (i64 4321 to ptr)
;.
; CHECK-LABEL: define {{[^@]+}}@bitcast_nonzero_i128_to_cap() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ALLOCA:%.*]] = alloca i128, align 16
; CHECK-NEXT:    store i128 4321, ptr [[ALLOCA]], align 16
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast ptr [[ALLOCA]] to ptr
; CHECK-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr [[TMP0]], align 16
; CHECK-NEXT:    store ptr addrspace(200) [[TMP1]], ptr @cap_from_bitcast_nonzero, align 16
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@inttoptr_nonzero_i128_to_cap() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ALLOCA:%.*]] = alloca i128, align 16
; CHECK-NEXT:    store i128 4321, ptr [[ALLOCA]], align 16
; CHECK-NEXT:    [[VAL:%.*]] = load i128, ptr [[ALLOCA]], align 16
; CHECK-NEXT:    [[TRUNC:%.*]] = trunc i128 [[VAL]] to i64
; CHECK-NEXT:    [[CAST:%.*]] = inttoptr i64 [[TRUNC]] to ptr addrspace(200)
; CHECK-NEXT:    store ptr addrspace(200) [[CAST]], ptr @cap_from_i128_inttoptr_nonzero, align 16
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define {{[^@]+}}@inttoptr_nonzero_i64_to_cap() {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ALLOCA:%.*]] = alloca i64, align 16
; CHECK-NEXT:    store i64 4321, ptr [[ALLOCA]], align 16
; CHECK-NEXT:    [[VAL:%.*]] = load i64, ptr [[ALLOCA]], align 16
; CHECK-NEXT:    [[CAST:%.*]] = inttoptr i64 [[VAL]] to ptr addrspace(200)
; CHECK-NEXT:    store ptr addrspace(200) [[CAST]], ptr @cap_from_i64_inttoptr_nonzero, align 16
; CHECK-NEXT:    ret void
;
