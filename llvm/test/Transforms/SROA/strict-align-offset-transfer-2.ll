; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes
; RUN: sed -e 's/@PTR_AS@/200/g' -e 's/@PTR_PAIR_SIZE@/32/g' %s \
; RUN:   | opt -S -passes=sroa -o - | FileCheck %s
; RUN: sed -e 's/@PTR_AS@/0/g' -e 's/@PTR_PAIR_SIZE@/16/g' -e 's/-pf200:128:128:128:64//g' %s \
; RUN:   | opt -S -passes=sroa -o - | FileCheck %s --check-prefix NOCHERI
target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A@PTR_AS@-P@PTR_AS@-G@PTR_AS@"
target triple = "riscv64"
; Regression test found while compiling busybox awk. This was created based on from the following reduced C code:
; void a() {
;   struct {
;     int *b;
;     char c;
;   } d = d;
; }
; The fix for this is the same as for the strict-align-offset-transfer.ll regression test, but
; it triggered a different assertion:
; Slices of alloca:   %d = alloca %struct.anon, align 16, addrspace(200)
;    [0,32) slice #0 (splittable)
;      used by:   call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* %0, i8 addrspace(200)* %1, i64 32, i1 false)
;  Pre-splitting loads and stores
;    Searching for candidate loads and stores
;  Rewriting alloca partition [0,32) to:   %d = alloca %struct.anon, align 16, addrspace(200)
;    rewriting [0,32) slice #0 (splittable)
;  Assertion failed: (isa<X>(Val) && "cast<Ty>() argument of incompatible type!"),

%struct.anon = type { ptr addrspace(@PTR_AS@), i8 }

define void @previously_crashing_testcase() nounwind {
; CHECK-LABEL: define {{[^@]+}}@previously_crashing_testcase
; CHECK-SAME: () addrspace(200) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret void
;
; NOCHERI-LABEL: define {{[^@]+}}@previously_crashing_testcase
; NOCHERI-SAME: () #[[ATTR0:[0-9]+]] {
; NOCHERI-NEXT:  entry:
; NOCHERI-NEXT:    ret void
;
entry:
  %d = alloca %struct.anon, align 16, addrspace(@PTR_AS@)
  %0 = bitcast ptr addrspace(@PTR_AS@) %d to ptr addrspace(@PTR_AS@)
  %1 = bitcast ptr addrspace(@PTR_AS@) %d to ptr addrspace(@PTR_AS@)
  call void @llvm.memcpy.p@PTR_AS@.p@PTR_AS@.i64(ptr addrspace(@PTR_AS@) %0, ptr addrspace(@PTR_AS@) %1, i64 @PTR_PAIR_SIZE@, i1 false)
  ret void
}

declare void @use(ptr addrspace(@PTR_AS@))

define void @crashing_testcase_with_use() nounwind {
; CHECK-LABEL: define {{[^@]+}}@crashing_testcase_with_use
; CHECK-SAME: () addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[D:%.*]] = alloca [[STRUCT_ANON:%.*]], align 16, addrspace(200)
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast ptr addrspace(200) [[D]] to ptr addrspace(200)
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast ptr addrspace(200) [[D]] to ptr addrspace(200)
; CHECK-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) [[TMP0]], ptr addrspace(200) [[TMP1]], i64 32, i1 false)
; CHECK-NEXT:    call void @use(ptr addrspace(200) [[D]])
; CHECK-NEXT:    ret void
;
; NOCHERI-LABEL: define {{[^@]+}}@crashing_testcase_with_use
; NOCHERI-SAME: () #[[ATTR0]] {
; NOCHERI-NEXT:  entry:
; NOCHERI-NEXT:    [[D:%.*]] = alloca [[STRUCT_ANON:%.*]], align 16
; NOCHERI-NEXT:    [[TMP0:%.*]] = bitcast ptr [[D]] to ptr
; NOCHERI-NEXT:    [[TMP1:%.*]] = bitcast ptr [[D]] to ptr
; NOCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[TMP0]], ptr [[TMP1]], i64 16, i1 false)
; NOCHERI-NEXT:    call void @use(ptr [[D]])
; NOCHERI-NEXT:    ret void
;
entry:
  %d = alloca %struct.anon, align 16, addrspace(@PTR_AS@)
  %0 = bitcast ptr addrspace(@PTR_AS@) %d to ptr addrspace(@PTR_AS@)
  %1 = bitcast ptr addrspace(@PTR_AS@) %d to ptr addrspace(@PTR_AS@)
  call void @llvm.memcpy.p@PTR_AS@.p@PTR_AS@.i64(ptr addrspace(@PTR_AS@) %0, ptr addrspace(@PTR_AS@) %1, i64 @PTR_PAIR_SIZE@, i1 false)
  ; Note: memcpy() not removed if there is another use -> this did not assert
  call void @use(ptr addrspace(@PTR_AS@) %d)
  ret void
}


define void @working_testcase() nounwind {
; CHECK-LABEL: define {{[^@]+}}@working_testcase
; CHECK-SAME: () addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret void
;
; NOCHERI-LABEL: define {{[^@]+}}@working_testcase
; NOCHERI-SAME: () #[[ATTR0]] {
; NOCHERI-NEXT:  entry:
; NOCHERI-NEXT:    ret void
;
entry:
  %d = alloca %struct.anon, align 16, addrspace(@PTR_AS@)
  %0 = bitcast ptr addrspace(@PTR_AS@) %d to ptr addrspace(@PTR_AS@)
  call void @llvm.memcpy.p@PTR_AS@.p@PTR_AS@.i64(ptr addrspace(@PTR_AS@) %0, ptr addrspace(@PTR_AS@) %0, i64 @PTR_PAIR_SIZE@, i1 false)
  ; Note: It was not asserting when both uses were the same bitcast, only when there were two different ones
  ret void
}

define void @working_testcase_with_use() nounwind {
; CHECK-LABEL: define {{[^@]+}}@working_testcase_with_use
; CHECK-SAME: () addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[D:%.*]] = alloca [[STRUCT_ANON:%.*]], align 16, addrspace(200)
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast ptr addrspace(200) [[D]] to ptr addrspace(200)
; CHECK-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) [[TMP0]], ptr addrspace(200) [[TMP0]], i64 32, i1 false)
; CHECK-NEXT:    call void @use(ptr addrspace(200) [[D]])
; CHECK-NEXT:    ret void
;
; NOCHERI-LABEL: define {{[^@]+}}@working_testcase_with_use
; NOCHERI-SAME: () #[[ATTR0]] {
; NOCHERI-NEXT:  entry:
; NOCHERI-NEXT:    [[D:%.*]] = alloca [[STRUCT_ANON:%.*]], align 16
; NOCHERI-NEXT:    [[TMP0:%.*]] = bitcast ptr [[D]] to ptr
; NOCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[TMP0]], ptr [[TMP0]], i64 16, i1 false)
; NOCHERI-NEXT:    call void @use(ptr [[D]])
; NOCHERI-NEXT:    ret void
;
entry:
  %d = alloca %struct.anon, align 16, addrspace(@PTR_AS@)
  %0 = bitcast ptr addrspace(@PTR_AS@) %d to ptr addrspace(@PTR_AS@)
  call void @llvm.memcpy.p@PTR_AS@.p@PTR_AS@.i64(ptr addrspace(@PTR_AS@) %0, ptr addrspace(@PTR_AS@) %0, i64 @PTR_PAIR_SIZE@, i1 false)
  call void @use(ptr addrspace(@PTR_AS@) %d)
  ret void
}

declare void @llvm.memcpy.p@PTR_AS@.p@PTR_AS@.i64(ptr addrspace(@PTR_AS@) noalias nocapture writeonly, ptr addrspace(@PTR_AS@) noalias nocapture readonly, i64, i1 immarg)
