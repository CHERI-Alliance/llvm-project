; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; This test case previously triggered assertions in SROA ("Partitions must span some bytes!")
; RUN: opt -mtriple=mips64-unknown-freebsd -mcpu=cheri128 -mattr=+cheri128 \
; RUN:     -S -passes=sroa < %s \
; RUN:     | FileCheck %s
target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128"

%struct = type { i32, i32, i32, i32, ptr addrspace(200), ptr addrspace(200) }

define void @foo() {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BUF_SROA_0:%.*]] = alloca [12 x i8], align 4
; CHECK-NEXT:    [[A_SROA_0:%.*]] = alloca { i32, i32, i32, i32 }, align 16
; CHECK-NEXT:    [[B_SROA_0:%.*]] = alloca { i32, i32, i32, i32 }, align 16
; CHECK-NEXT:    [[TMPA_SROA_0:%.*]] = alloca { i32, i32, i32, i32 }, align 16
; CHECK-NEXT:    [[TMPB_SROA_0:%.*]] = alloca { i32, i32, i32, i32 }, align 16
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 12, ptr [[BUF_SROA_0]])
; CHECK-NEXT:    [[TMPA_SROA_0_4_TMPA_CAST_4_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[TMPA_SROA_0]], i64 4
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[TMPA_SROA_0_4_TMPA_CAST_4_SROA_IDX]], ptr align 4 [[BUF_SROA_0]], i64 12, i1 false) #[[ATTR3:[0-9]+]]
; CHECK-NEXT:    [[TMPB_SROA_0_4_TMPB_CAST_4_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[TMPB_SROA_0]], i64 4
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[TMPB_SROA_0_4_TMPB_CAST_4_SROA_IDX]], ptr align 4 [[BUF_SROA_0]], i64 12, i1 false) #[[ATTR3]]
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 12, ptr [[BUF_SROA_0]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[A_SROA_0]], ptr align 16 [[TMPA_SROA_0]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[B_SROA_0]], ptr align 16 [[TMPB_SROA_0]], i64 16, i1 false)
; CHECK-NEXT:    ret void
;
entry:
  %buf = alloca [44 x i8], align 4
  %a = alloca %struct, align 16
  %b = alloca %struct, align 16
  %tmpa = alloca %struct, align 16
  %tmpb = alloca %struct, align 16
  %tmpa.cast = bitcast ptr %tmpa to ptr
  %tmpa.cast.4 = getelementptr inbounds i8, ptr %tmpa.cast, i64 4
  %buf.cast = getelementptr inbounds [44 x i8], ptr %buf, i64 0, i64 0
  call void @llvm.lifetime.start.p0(i64 44, ptr %buf.cast)
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %tmpa.cast.4, ptr align 4 %buf.cast, i64 44, i1 false)
  %tmpb.cast = bitcast ptr %tmpb to ptr
  %tmpb.cast.4 = getelementptr inbounds i8, ptr %tmpb.cast, i64 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %tmpb.cast.4, ptr align 4 %buf.cast, i64 44, i1 false)
  call void @llvm.lifetime.end.p0(i64 44, ptr %buf.cast)
  %a.cast = bitcast ptr %a to ptr
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %a.cast, ptr align 16 %tmpa.cast, i64 48, i1 false)
  %b.cast = bitcast ptr %b to ptr
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %b.cast, ptr align 16 %tmpb.cast, i64 48, i1 false)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #0

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #0

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #1

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
