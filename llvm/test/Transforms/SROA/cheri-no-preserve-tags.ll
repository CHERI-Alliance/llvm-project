; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
; RUN: opt -S -passes=sroa < %s | FileCheck %s
; This test case shows that we can make use of no_preserve_cheri_tags in SROA.
; It is based on @unaligned_copy_buf from cheri-cap-align.ll since I couldn't
; easily come up with a more minimal test case.
target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128"
target triple = "riscv64-unknown-freebsd"

define void @no_attribute(ptr %px) {
; CHECK-LABEL: define {{[^@]+}}@no_attribute
; CHECK-SAME: (ptr [[PX:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[PY_SROA_0:%.*]] = alloca [16 x i8], align 16
; CHECK-NEXT:    [[PY_SROA_2:%.*]] = alloca [16 x i8], align 16
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[PY_SROA_0]], ptr align 16 [[PX]], i64 16, i1 false)
; CHECK-NEXT:    [[PY_SROA_2_0_PX_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[PX]], i64 16
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[PY_SROA_2]], ptr align 16 [[PY_SROA_2_0_PX_SROA_IDX]], i64 16, i1 false)
; CHECK-NEXT:    [[PX_TAIL:%.*]] = getelementptr inbounds i8, ptr [[PX]], i64 4
; CHECK-NEXT:    [[PY_SROA_0_4_PY_TAIL_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[PY_SROA_0]], i64 4
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[PX_TAIL]], ptr align 4 [[PY_SROA_0_4_PY_TAIL_SROA_IDX]], i64 12, i1 false) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    [[PY_SROA_2_4_PX_TAIL_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr [[PX_TAIL]], i64 12
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[PY_SROA_2_4_PX_TAIL_SROA_IDX]], ptr align 16 [[PY_SROA_2]], i64 16, i1 false)
; CHECK-NEXT:    ret void
;
entry:
  %py = alloca [32 x i8], align 16
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %py, ptr align 16 %px, i64 32, i1 false)
  %px.tail = getelementptr inbounds i8, ptr %px, i64 4
  %py.tail = getelementptr inbounds i8, ptr %py, i64 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %px.tail, ptr align 4 %py.tail, i64 28, i1 false)
  ret void
}

define void @with_attribute(ptr %px) {
; CHECK-LABEL: define {{[^@]+}}@with_attribute
; CHECK-SAME: (ptr [[PX:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[PY:%.*]] = alloca [32 x i8], align 16
; CHECK-NEXT:    [[PX_CAST:%.*]] = bitcast ptr [[PX]] to ptr
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[PY]], ptr align 16 [[PX]], i64 32, i1 false) #[[ATTR1]]
; CHECK-NEXT:    [[PX_TAIL:%.*]] = getelementptr inbounds i8, ptr [[PX]], i64 4
; CHECK-NEXT:    [[PY_TAIL:%.*]] = getelementptr inbounds i8, ptr [[PY]], i64 4
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[PX_TAIL]], ptr align 4 [[PY_TAIL]], i64 28, i1 false) #[[ATTR1]]
; CHECK-NEXT:    ret void
;
entry:
  %py = alloca [32 x i8], align 16
  %px.cast = bitcast ptr %px to ptr
  %py.cast = bitcast ptr %py to ptr
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %py, ptr align 16 %px, i64 32, i1 false) #1
  %px.tail = getelementptr inbounds i8, ptr %px, i64 4
  %py.tail = getelementptr inbounds i8, ptr %py, i64 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %px.tail, ptr align 4 %py.tail, i64 28, i1 false) #1
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #0

attributes #0 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #1 = { no_preserve_cheri_tags }

; UTC_ARGS: --disable
; CHECK: attributes #[[ATTR1]] = { no_preserve_cheri_tags }
