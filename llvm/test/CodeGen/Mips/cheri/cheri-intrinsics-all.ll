; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri_llc -O0 %s -o - | FileCheck %s

@results = common global [12 x ptr addrspace(200)] zeroinitializer, align 32

; Function Attrs: nounwind
define i64 @test(ptr addrspace(200) %rfoo) #0 {
; CHECK-LABEL: test:
; CHECK:       # %bb.0:
; CHECK-NEXT:    daddiu $sp, $sp, -64
; CHECK-NEXT:    sd $ra, 56($sp) # 8-byte Folded Spill
; CHECK-NEXT:    sd $fp, 48($sp) # 8-byte Folded Spill
; CHECK-NEXT:    move $fp, $sp
; CHECK-NEXT:    daddiu $1, $zero, -32
; CHECK-NEXT:    and $sp, $sp, $1
; CHECK-NEXT:    daddiu $4, $sp, 32
; CHECK-NEXT:    csc $c3, $4, 0($ddc)
; CHECK-NEXT:    clc $c1, $4, 0($ddc)
; CHECK-NEXT:    cgetlen $2, $c1
; CHECK-NEXT:    ld $1, 24($sp)
; CHECK-NEXT:    and $1, $1, $2
; CHECK-NEXT:    sd $1, 24($sp)
; CHECK-NEXT:    clc $c1, $4, 0($ddc)
; CHECK-NEXT:    cgetperm $1, $c1
; CHECK-NEXT:    dsll $1, $1, 48
; CHECK-NEXT:    dsra $2, $1, 48
; CHECK-NEXT:    ld $1, 24($sp)
; CHECK-NEXT:    and $1, $1, $2
; CHECK-NEXT:    sd $1, 24($sp)
; CHECK-NEXT:    clc $c1, $4, 0($ddc)
; CHECK-NEXT:    cgetflags $2, $c1
; CHECK-NEXT:    ld $1, 24($sp)
; CHECK-NEXT:    and $1, $1, $2
; CHECK-NEXT:    sd $1, 24($sp)
; CHECK-NEXT:    clc $c1, $4, 0($ddc)
; CHECK-NEXT:    cgettype $2, $c1
; CHECK-NEXT:    ld $1, 24($sp)
; CHECK-NEXT:    and $1, $1, $2
; CHECK-NEXT:    sd $1, 24($sp)
; CHECK-NEXT:    clc $c2, $4, 0($ddc)
; CHECK-NEXT:    cgettag $2, $c2
; CHECK-NEXT:    ld $1, 24($sp)
; CHECK-NEXT:    and $1, $1, $2
; CHECK-NEXT:    sd $1, 24($sp)
; CHECK-NEXT:    clc $c1, $4, 0($ddc)
; CHECK-NEXT:    daddiu $1, $zero, 12
; CHECK-NEXT:    candperm $c1, $c1, $1
; CHECK-NEXT:    lui $2, %highest(results)
; CHECK-NEXT:    daddiu $2, $2, %higher(results)
; CHECK-NEXT:    dsll $2, $2, 16
; CHECK-NEXT:    daddiu $2, $2, %hi(results)
; CHECK-NEXT:    dsll $2, $2, 16
; CHECK-NEXT:    daddiu $2, $2, %lo(results)
; CHECK-NEXT:    daddiu $3, $2, 16
; CHECK-NEXT:    csc $c1, $3, 0($ddc)
; CHECK-NEXT:    clc $c1, $4, 0($ddc)
; CHECK-NEXT:    daddiu $3, $zero, 0
; CHECK-NEXT:    csetflags $c1, $c1, $zero
; CHECK-NEXT:    daddiu $3, $2, 32
; CHECK-NEXT:    csc $c1, $3, 0($ddc)
; CHECK-NEXT:    clc $c1, $4, 0($ddc)
; CHECK-NEXT:    cseal $c3, $c1, $c1
; CHECK-NEXT:    daddiu $3, $2, 64
; CHECK-NEXT:    csc $c3, $3, 0($ddc)
; CHECK-NEXT:    clc $c3, $4, 0($ddc)
; CHECK-NEXT:    cunseal $c3, $c3, $c3
; CHECK-NEXT:    daddiu $2, $2, 80
; CHECK-NEXT:    csc $c3, $2, 0($ddc)
; CHECK-NEXT:    daddiu $2, $zero, 42
; CHECK-NEXT:    csetcause $2
; CHECK-NEXT:    ld $2, 24($sp)
; CHECK-NEXT:    cgetcause $3
; CHECK-NEXT:    and $3, $2, $3
; CHECK-NEXT:    cgetsealed $2, $c2
; CHECK-NEXT:    clc $c2, $4, 0($ddc)
; CHECK-NEXT:    and $3, $2, $3
; CHECK-NEXT:    ctestsubset $2, $c2, $c2
; CHECK-NEXT:    sltu $4, $zero, $2
; CHECK-NEXT:    # implicit-def: $v0_64
; CHECK-NEXT:    move $2, $4
; CHECK-NEXT:    and $2, $2, $3
; CHECK-NEXT:    ccheckperm $c1, $1
; CHECK-NEXT:    cchecktype $c1, $c1
; CHECK-NEXT:    move $sp, $fp
; CHECK-NEXT:    ld $fp, 48($sp) # 8-byte Folded Reload
; CHECK-NEXT:    ld $ra, 56($sp) # 8-byte Folded Reload
; CHECK-NEXT:    daddiu $sp, $sp, 64
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    nop
  %r1 = alloca ptr addrspace(200), align 32
  %rx = alloca i64, align 8
  store ptr addrspace(200) %rfoo, ptr %r1, align 32
  %r2 = load ptr addrspace(200), ptr %r1, align 32
  %r3 = call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) %r2)
  %r4 = load i64, ptr %rx, align 8
  %r5 = and i64 %r4, %r3
  store i64 %r5, ptr %rx, align 8
  %r6 = load ptr addrspace(200), ptr %r1, align 32
  %r7 = call i64 @llvm.cheri.cap.perms.get.i64(ptr addrspace(200) %r6)
  %r8 = trunc i64 %r7 to i16
  %r9 = sext i16 %r8 to i64
  %r10 = load i64, ptr %rx, align 8
  %r11 = and i64 %r10, %r9
  store i64 %r11, ptr %rx, align 8
  %rgetflags1 = load ptr addrspace(200), ptr %r1, align 32
  %rgetflags2 = call i64 @llvm.cheri.cap.flags.get.i64(ptr addrspace(200) %rgetflags1)
  %rgetflags3 = load i64, ptr %rx, align 8
  %rgetflags4 = and i64 %rgetflags3, %rgetflags2
  store i64 %rgetflags4, ptr %rx, align 8
  %r12 = load ptr addrspace(200), ptr %r1, align 32
  %r13 = call i64 @llvm.cheri.cap.type.get.i64(ptr addrspace(200) %r12)
  %r14 = load i64, ptr %rx, align 8
  %r15 = and i64 %r14, %r13
  store i64 %r15, ptr %rx, align 8
  %r16 = load ptr addrspace(200), ptr %r1, align 32
  %r18 = call i1 @llvm.cheri.cap.tag.get(ptr addrspace(200) %r16)
  %r19 = zext i1 %r18 to i64
  %r20 = load i64, ptr %rx, align 8
  %r21 = and i64 %r20, %r19
  store i64 %r21, ptr %rx, align 8
  %r22 = load ptr addrspace(200), ptr %r1, align 32
  %r24 = load ptr addrspace(200), ptr %r1, align 32
  %r25 = call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) %r24, i64 12)
  store ptr addrspace(200) %r25, ptr getelementptr inbounds ([12 x ptr addrspace(200)], ptr @results, i32 0, i64 1), align 32
  %r26 = load ptr addrspace(200), ptr %r1, align 32
  %r27 = call ptr addrspace(200) @llvm.cheri.cap.flags.set.i64(ptr addrspace(200) %r26, i64 0)
  store ptr addrspace(200) %r27, ptr getelementptr inbounds ([12 x ptr addrspace(200)], ptr @results, i32 0, i64 2), align 32
  %r30 = load ptr addrspace(200), ptr %r1, align 32
  %r31 = load ptr addrspace(200), ptr %r1, align 32
  %r32 = call ptr addrspace(200) @llvm.cheri.cap.seal(ptr addrspace(200) %r30, ptr addrspace(200) %r31)
  store ptr addrspace(200) %r32, ptr getelementptr inbounds ([12 x ptr addrspace(200)], ptr @results, i32 0, i64 4), align 32
  %r33 = load ptr addrspace(200), ptr %r1, align 32
  %r34 = load ptr addrspace(200), ptr %r1, align 32
  %r35 = call ptr addrspace(200) @llvm.cheri.cap.unseal(ptr addrspace(200) %r33, ptr addrspace(200) %r34)
  store ptr addrspace(200) %r35, ptr getelementptr inbounds ([12 x ptr addrspace(200)], ptr @results, i32 0, i64 5), align 32
  call void @llvm.mips.cap.cause.set(i64 42)
  %r36 = load i64, ptr %rx, align 8
  %r37 = call i64 @llvm.mips.cap.cause.get()
  %r38 = and i64 %r36, %r37
  %r40 = call i1 @llvm.cheri.cap.sealed.get(ptr addrspace(200) %r16)
  %r41 = zext i1 %r40 to i64
  %r42 = load ptr addrspace(200), ptr %r1, align 32
  %r43 = load ptr addrspace(200), ptr %r1, align 32
  %r44 = and i64 %r41, %r38
  %r46 = call i1 @llvm.cheri.cap.subset.test(ptr addrspace(200) %r42, ptr addrspace(200) %r43)
  %r47 = zext i1 %r46 to i64
  %r48 = and i64 %r47, %r44
  call void @llvm.cheri.cap.perms.check.i64(ptr addrspace(200) %r30, i64 12)
  call void @llvm.cheri.cap.type.check(ptr addrspace(200) %r30, ptr addrspace(200) %r31)
  ret i64 %r48
}

; Function Attrs: nounwind willreturn memory(none)
declare i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200)) #1

; Function Attrs: nounwind willreturn memory(none)
declare i64 @llvm.cheri.cap.perms.get.i64(ptr addrspace(200)) #1

; Function Attrs: nounwind willreturn memory(none)
declare i64 @llvm.cheri.cap.flags.get.i64(ptr addrspace(200)) #1

; Function Attrs: nounwind willreturn memory(none)
declare i64 @llvm.cheri.cap.type.get.i64(ptr addrspace(200)) #1

; Function Attrs: nounwind willreturn memory(none)
declare i1 @llvm.cheri.cap.sealed.get(ptr addrspace(200)) #1

; Function Attrs: nounwind willreturn memory(none)
declare i1 @llvm.cheri.cap.tag.get(ptr addrspace(200)) #1

; Function Attrs: nounwind memory(none)
declare ptr addrspace(200) @llvm.cheri.cap.length.set(ptr addrspace(200), i64) #2

; Function Attrs: nounwind willreturn memory(none)
declare ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200), i64) #1

; Function Attrs: nounwind willreturn memory(none)
declare ptr addrspace(200) @llvm.cheri.cap.flags.set.i64(ptr addrspace(200), i64) #1

; Function Attrs: nounwind memory(none)
declare ptr addrspace(200) @llvm.cheri.cap.type.set(ptr addrspace(200), i64) #2

; Function Attrs: nounwind willreturn memory(none)
declare ptr addrspace(200) @llvm.cheri.cap.seal(ptr addrspace(200), ptr addrspace(200)) #1

; Function Attrs: nounwind willreturn memory(none)
declare ptr addrspace(200) @llvm.cheri.cap.unseal(ptr addrspace(200), ptr addrspace(200)) #1

; Function Attrs: hassideeffects nounwind willreturn
declare void @llvm.cheri.cap.perms.check.i64(ptr addrspace(200), i64) #3

; Function Attrs: hassideeffects nounwind willreturn
declare void @llvm.cheri.cap.type.check(ptr addrspace(200), ptr addrspace(200)) #3

; Function Attrs: nounwind willreturn memory(none)
declare i1 @llvm.cheri.cap.subset.test(ptr addrspace(200), ptr addrspace(200)) #1

; Function Attrs: nounwind
declare void @llvm.mips.cap.cause.set(i64) #4

; Function Attrs: nounwind
declare i64 @llvm.mips.cap.cause.get() #4

attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind willreturn memory(none) }
attributes #2 = { nounwind memory(none) }
attributes #3 = { hassideeffects nounwind willreturn }
attributes #4 = { nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.4 "}
