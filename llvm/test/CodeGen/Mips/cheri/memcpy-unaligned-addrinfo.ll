; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; This used to split the memcpy/memmove in sroa and create broken output
; RUN: %cheri_purecap_opt -passes=sroa -S %s -o - | FileCheck %s -check-prefix SROA
; RUN: %cheri_purecap_opt -passes=sroa -S %s -o - | %cheri_purecap_llc -O2 - -o - | FileCheck %s -check-prefixes=CHECK,WITH-SROA
; RUN: %cheri_purecap_llc -O2 %s -o - | FileCheck %s  -check-prefixes=CHECK,WITHOUT-SROA
target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"

%struct.addrinfo = type { ptr addrspace(200) }

; Function Attrs: noinline nounwind
define inreg { ptr addrspace(200) } @do_not_split_cap_memcpy(ptr addrspace(200) %a) addrspace(200) #0 {
; SROA-LABEL: @do_not_split_cap_memcpy(
; SROA-NEXT:  entry:
; SROA-NEXT:    [[RETVAL_SROA_0_0_COPYLOAD:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[A:%.*]], align 1
; SROA-NEXT:    [[DOTFCA_0_INSERT:%.*]] = insertvalue { ptr addrspace(200) } poison, ptr addrspace(200) [[RETVAL_SROA_0_0_COPYLOAD]], 0
; SROA-NEXT:    ret { ptr addrspace(200) } [[DOTFCA_0_INSERT]]
;
entry:
  %retval = alloca %struct.addrinfo, align 16, addrspace(200)
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) noundef nonnull align 16 dereferenceable(16) %retval, ptr addrspace(200) noundef nonnull align 1 dereferenceable(16) %a, i64 16, i1 false)
  %.unpack = load ptr addrspace(200), ptr addrspace(200) %retval, align 16
  %0 = insertvalue { ptr addrspace(200) } poison, ptr addrspace(200) %.unpack, 0
  ret { ptr addrspace(200) } %0
}

; CHECK-LABEL: do_not_split_cap_memcpy:
; CHECK:	clcbi	$c12, %capcall20(memcpy)($c1)
; CHECK-DAG:	csetbounds	$c3, $c{{3|11}}, 16
; CHECK-DAG:	cjalr	$c12, $c17
; CHECK-DAG:	daddiu	$4, $zero, 16
; CHECK: cjr $c17

; Function Attrs: noinline nounwind
define inreg { ptr addrspace(200) } @do_not_split_cap_memmove(ptr addrspace(200) %a) addrspace(200) #0 {
; SROA-LABEL: @do_not_split_cap_memmove(
; SROA-NEXT:  entry:
; SROA-NEXT:    [[RETVAL_SROA_0_0_COPYLOAD:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[A:%.*]], align 1
; SROA-NEXT:    [[DOTFCA_0_INSERT:%.*]] = insertvalue { ptr addrspace(200) } poison, ptr addrspace(200) [[RETVAL_SROA_0_0_COPYLOAD]], 0
; SROA-NEXT:    ret { ptr addrspace(200) } [[DOTFCA_0_INSERT]]
;
entry:
  %retval = alloca %struct.addrinfo, align 16, addrspace(200)
  call void @llvm.memmove.p200.p200.i64(ptr addrspace(200) noundef nonnull align 16 dereferenceable(16) %retval, ptr addrspace(200) noundef nonnull align 1 dereferenceable(16) %a, i64 16, i1 false)
  %.unpack = load ptr addrspace(200), ptr addrspace(200) %retval, align 16
  %0 = insertvalue { ptr addrspace(200) } poison, ptr addrspace(200) %.unpack, 0
  ret { ptr addrspace(200) } %0
}
; CHECK-LABEL: do_not_split_cap_memmove:
; Converted to a memcpy to the stack
; WITH-SROA:	clcbi	$c12, %capcall20(memcpy)($c1)
; WITHOUT-SROA:	clcbi	$c12, %capcall20(memmove)($c1)
; CHECK-DAG:	csetbounds	$c3, $c{{3|11}}, 16
; CHECK-DAG:	cjalr	$c12, $c17
; CHECK-DAG:	daddiu	$4, $zero, 16
; CHECK: cjr $c17

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) noalias nocapture writeonly, ptr addrspace(200) noalias nocapture readonly, i64, i1 immarg) addrspace(200) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p200.p200.i64(ptr addrspace(200) nocapture writeonly, ptr addrspace(200) nocapture readonly, i64, i1 immarg) addrspace(200) #1

attributes #0 = { noinline nounwind }
attributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
