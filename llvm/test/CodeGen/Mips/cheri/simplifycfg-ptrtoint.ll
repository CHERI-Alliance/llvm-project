; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -data-layout="E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200" -S -passes=instcombine %s -o - | FileCheck -check-prefix INSTCOMBINE %s
; RUN: opt -data-layout="E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200" -S -O2 %s -o - | FileCheck -check-prefix IR %s
; RUN: opt -data-layout="E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200" -S -O2 %s -o - | %cheri_purecap_llc -O2 -o - | %cheri_FileCheck %s -check-prefix ASM

; After fixing valuetracking to look through address set intrinsics,
; SimplifyCFG would create a ptrtoint for this three value check:

; Original C source code:
; typedef __UINTPTR_TYPE__ uintptr_t;
; void finalizer(void (*fn)(void)) {
;   if ((uintptr_t) fn != 0 && (uintptr_t) fn != 1 && (uintptr_t) fn != 2)
;     (fn)();
; }

; target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"
target triple = "cheri-unknown-freebsd"

; Function Attrs: nounwind
define void @cannot_fold_tag_unknown(ptr addrspace(200) %fn) local_unnamed_addr addrspace(200) #0 {
; INSTCOMBINE-LABEL: @cannot_fold_tag_unknown(
; INSTCOMBINE-NEXT:  entry:
; INSTCOMBINE-NEXT:    [[CMP:%.*]] = icmp eq ptr addrspace(200) [[FN:%.*]], null
; INSTCOMBINE-NEXT:    br i1 [[CMP]], label [[IF_END:%.*]], label [[LAND_LHS_TRUE:%.*]]
; INSTCOMBINE:       land.lhs.true:
; INSTCOMBINE-NEXT:    [[CMP1:%.*]] = icmp eq ptr addrspace(200) [[FN]], getelementptr (i8, ptr addrspace(200) null, i64 1)
; INSTCOMBINE-NEXT:    br i1 [[CMP1]], label [[IF_END]], label [[LAND_LHS_TRUE2:%.*]]
; INSTCOMBINE:       land.lhs.true2:
; INSTCOMBINE-NEXT:    [[CMP3:%.*]] = icmp eq ptr addrspace(200) [[FN]], getelementptr (i8, ptr addrspace(200) null, i64 2)
; INSTCOMBINE-NEXT:    br i1 [[CMP3]], label [[IF_END]], label [[IF_THEN:%.*]]
; INSTCOMBINE:       if.then:
; INSTCOMBINE-NEXT:    tail call void @foo(ptr addrspace(200) nonnull [[FN]]) #[[ATTR0:[0-9]+]]
; INSTCOMBINE-NEXT:    br label [[IF_END]]
; INSTCOMBINE:       if.end:
; INSTCOMBINE-NEXT:    ret void
;
; IR-LABEL: @cannot_fold_tag_unknown(
; IR-NEXT:  entry:
; IR-NEXT:    [[CMP:%.*]] = icmp eq ptr addrspace(200) [[FN:%.*]], null
; IR-NEXT:    [[CMP1:%.*]] = icmp eq ptr addrspace(200) [[FN]], getelementptr (i8, ptr addrspace(200) null, i64 1)
; IR-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP]], [[CMP1]]
; IR-NEXT:    [[CMP3:%.*]] = icmp eq ptr addrspace(200) [[FN]], getelementptr (i8, ptr addrspace(200) null, i64 2)
; IR-NEXT:    [[OR_COND1:%.*]] = or i1 [[CMP3]], [[OR_COND]]
; IR-NEXT:    br i1 [[OR_COND1]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; IR:       if.then:
; IR-NEXT:    tail call void @foo(ptr addrspace(200) nonnull [[FN]]) #[[ATTR0:[0-9]+]]
; IR-NEXT:    br label [[IF_END]]
; IR:       if.end:
; IR-NEXT:    ret void
;
entry:
  %0 = bitcast ptr addrspace(200) %fn to ptr addrspace(200)
  %cmp = icmp eq ptr addrspace(200) %fn, null
  br i1 %cmp, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = tail call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) null, i64 1)
  %cmp1 = icmp eq ptr addrspace(200) %1, %0
  br i1 %cmp1, label %if.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = tail call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) null, i64 2)
  %cmp3 = icmp eq ptr addrspace(200) %2, %0
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  tail call void @foo(ptr addrspace(200) %0)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind
define void @can_fold_tag_unset(ptr addrspace(200) %fn_tagged) local_unnamed_addr #0 {
; Running instcombine should convert this to a vaddr compare and simplifycfg will then convert it to a single cmp
; INSTCOMBINE-LABEL: @can_fold_tag_unset(
; INSTCOMBINE-NEXT:  entry:
; INSTCOMBINE-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.tag.clear(ptr addrspace(200) [[FN_TAGGED:%.*]])
; INSTCOMBINE-NEXT:    [[OP0_ADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
; INSTCOMBINE-NEXT:    [[CMP:%.*]] = icmp eq i64 [[OP0_ADDR]], 0
; INSTCOMBINE-NEXT:    br i1 [[CMP]], label [[IF_END:%.*]], label [[LAND_LHS_TRUE:%.*]]
; INSTCOMBINE:       land.lhs.true:
; INSTCOMBINE-NEXT:    [[OP0_ADDR1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
; INSTCOMBINE-NEXT:    [[CMP1:%.*]] = icmp eq i64 [[OP0_ADDR1]], 1
; INSTCOMBINE-NEXT:    br i1 [[CMP1]], label [[IF_END]], label [[LAND_LHS_TRUE2:%.*]]
; INSTCOMBINE:       land.lhs.true2:
; INSTCOMBINE-NEXT:    [[OP0_ADDR2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
; INSTCOMBINE-NEXT:    [[CMP3:%.*]] = icmp eq i64 [[OP0_ADDR2]], 2
; INSTCOMBINE-NEXT:    br i1 [[CMP3]], label [[IF_END]], label [[IF_THEN:%.*]]
; INSTCOMBINE:       if.then:
; INSTCOMBINE-NEXT:    tail call void @foo(ptr addrspace(200) [[FN_TAGGED]]) #[[ATTR0]]
; INSTCOMBINE-NEXT:    br label [[IF_END]]
; INSTCOMBINE:       if.end:
; INSTCOMBINE-NEXT:    ret void
;
; IR-LABEL: @can_fold_tag_unset(
; IR-NEXT:  entry:
; IR-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.tag.clear(ptr addrspace(200) [[FN_TAGGED:%.*]])
; IR-NEXT:    [[OP0_ADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
; IR-NEXT:    [[SWITCH:%.*]] = icmp ult i64 [[OP0_ADDR]], 3
; IR-NEXT:    br i1 [[SWITCH]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; IR:       if.then:
; IR-NEXT:    tail call void @foo(ptr addrspace(200) [[FN_TAGGED]]) #[[ATTR0]]
; IR-NEXT:    br label [[IF_END]]
; IR:       if.end:
; IR-NEXT:    ret void
;
; Much better with simplifycfg:
; ASM-LABEL: can_fold_tag_unset:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    ccleartag $c1, $c3
; ASM-NEXT:    cgetaddr $1, $c1
; ASM-NEXT:    sltiu $1, $1, 3
; ASM-NEXT:    bnez $1, .LBB1_2
; ASM-NEXT:    nop
; ASM-NEXT:  # %bb.1: # %if.then
; ASM-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; ASM-NEXT:    csc $c17, $zero, 0($c11)
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c1, $1
; ASM-NEXT:    clcbi $c12, %capcall20(foo)($c1)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    nop
; ASM-NEXT:    clc $c17, $zero, 0($c11)
; ASM-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
; ASM-NEXT:  .LBB1_2: # %if.end
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    nop
entry:
  %fn_i8 = bitcast ptr addrspace(200) %fn_tagged to ptr addrspace(200)
  %0 = call ptr addrspace(200) @llvm.cheri.cap.tag.clear(ptr addrspace(200) %fn_i8)
  %cmp = icmp eq ptr addrspace(200) %0, null
  br i1 %cmp, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = tail call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) null, i64 1)
  %cmp1 = icmp eq ptr addrspace(200) %1, %0
  br i1 %cmp1, label %if.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = tail call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) null, i64 2)
  %cmp3 = icmp eq ptr addrspace(200) %2, %0
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  tail call void @foo(ptr addrspace(200) %fn_i8)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true2, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind willreturn memory(none)
declare ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200), i64) #1

; Function Attrs: nounwind willreturn memory(none)
declare ptr addrspace(200) @llvm.cheri.cap.tag.clear(ptr addrspace(200)) #1

; Function Attrs: nounwind willreturn memory(none)
declare i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200)) #1

declare void @foo(ptr addrspace(200))

attributes #0 = { nounwind }
attributes #1 = { nounwind willreturn memory(none) }
