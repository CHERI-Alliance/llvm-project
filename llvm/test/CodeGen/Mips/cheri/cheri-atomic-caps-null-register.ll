; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUNs: %cheri_purecap_llc -cheri-cap-table-abi=pcrel %s -o - -O0 -print-before=atomic-expand -print-after=atomic-expand -debug-only=atomic-expand
; RUN: %cheri_purecap_llc -verify-machineinstrs -cheri-cap-table-abi=pcrel %s -o - -O2 | FileCheck %s -enable-var-scope
; ModuleID = 'atomic.c'

@cap = common addrspace(200) global ptr addrspace(200) null, align 32

declare void @test(ptr addrspace(200) nocapture, i1)

; Function Attrs: nounwind
define i32 @cmpxchg_null_ptr(ptr addrspace(200) nocapture %exp, ptr addrspace(200) %newval) #0 {
; CHECK-LABEL: cmpxchg_null_ptr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -16
; CHECK-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; CHECK-NEXT:    cgetnull $c2
; CHECK-NEXT:    sync
; CHECK-NEXT:  .LBB0_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c2
; CHECK-NEXT:    ceq $1, $c1, $c3
; CHECK-NEXT:    beqz $1, .LBB0_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    # in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    cscc $1, $c4, $c2
; CHECK-NEXT:    beqz $1, .LBB0_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB0_3: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c2, $1
; CHECK-NEXT:    ceq $4, $c1, $c3
; CHECK-NEXT:    sync
; CHECK-NEXT:    clcbi $c12, %capcall20(test)($c2)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    cmove $c3, $c1
; CHECK-NEXT:    addiu $2, $zero, 42
; CHECK-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 16
entry:
  %0 = cmpxchg ptr addrspace(200) null, ptr addrspace(200) %exp, ptr addrspace(200) %newval seq_cst seq_cst
  %1 = extractvalue { ptr addrspace(200), i1 } %0, 0
  %2 = extractvalue { ptr addrspace(200), i1 } %0, 1
  call void @test(ptr addrspace(200) nocapture %1, i1 %2)
  ret i32 42
}

; Function Attrs: nounwind
define i32 @cmpxchg_null_exp(ptr addrspace(200) %newval) #0 {
; CHECK-LABEL: cmpxchg_null_exp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -16
; CHECK-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c2, $1
; CHECK-NEXT:    clcbi $c4, %captab20(cap)($c2)
; CHECK-NEXT:    sync
; CHECK-NEXT:  .LBB1_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c4
; CHECK-NEXT:    ceq $1, $c1, $cnull
; CHECK-NEXT:    beqz $1, .LBB1_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    # in Loop: Header=BB1_1 Depth=1
; CHECK-NEXT:    cscc $1, $c3, $c4
; CHECK-NEXT:    beqz $1, .LBB1_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB1_3: # %entry
; CHECK-NEXT:    ceq $4, $c1, $cnull
; CHECK-NEXT:    sync
; CHECK-NEXT:    clcbi $c12, %capcall20(test)($c2)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    cmove $c3, $c1
; CHECK-NEXT:    addiu $2, $zero, 42
; CHECK-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 16
entry:
  %0 = cmpxchg ptr addrspace(200) @cap, ptr addrspace(200) null, ptr addrspace(200) %newval seq_cst seq_cst
  %1 = extractvalue { ptr addrspace(200), i1 } %0, 0
  %2 = extractvalue { ptr addrspace(200), i1 } %0, 1
  call void @test(ptr addrspace(200) nocapture %1, i1 %2)
  ret i32 42
}

; Function Attrs: nounwind
define i32 @cmpxchg_null_newval(ptr addrspace(200) %exp) #0 {
; CHECK-LABEL: cmpxchg_null_newval:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -16
; CHECK-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c2, $1
; CHECK-NEXT:    clcbi $c4, %captab20(cap)($c2)
; CHECK-NEXT:    sync
; CHECK-NEXT:  .LBB2_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c4
; CHECK-NEXT:    ceq $1, $c1, $c3
; CHECK-NEXT:    beqz $1, .LBB2_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    # in Loop: Header=BB2_1 Depth=1
; CHECK-NEXT:    cscc $1, $cnull, $c4
; CHECK-NEXT:    beqz $1, .LBB2_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB2_3: # %entry
; CHECK-NEXT:    ceq $4, $c1, $c3
; CHECK-NEXT:    sync
; CHECK-NEXT:    clcbi $c12, %capcall20(test)($c2)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    cmove $c3, $c1
; CHECK-NEXT:    addiu $2, $zero, 42
; CHECK-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 16
entry:
  %0 = cmpxchg ptr addrspace(200) @cap, ptr addrspace(200) %exp, ptr addrspace(200) null seq_cst seq_cst
  %1 = extractvalue { ptr addrspace(200), i1 } %0, 0
  %2 = extractvalue { ptr addrspace(200), i1 } %0, 1
  call void @test(ptr addrspace(200) nocapture %1, i1 %2)
  ret i32 42
}

; Function Attrs: nounwind
define ptr addrspace(200) @load_atomic_null_ptr() #0 {
; CHECK-LABEL: load_atomic_null_ptr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cgetnull $c1
; CHECK-NEXT:    clc $c3, $zero, 0($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
  %x = load atomic ptr addrspace(200), ptr addrspace(200) null seq_cst, align 32
  ret ptr addrspace(200) %x
}

; Function Attrs: nounwind
define void @store_atomic_null_ptr(ptr addrspace(200) %value) #0 {
; CHECK-LABEL: store_atomic_null_ptr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cgetnull $c1
; CHECK-NEXT:    sync
; CHECK-NEXT:    csc $c3, $zero, 0($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
  store atomic ptr addrspace(200) %value, ptr addrspace(200) null seq_cst, align 32
  ret void
}

; Function Attrs: nounwind
define void @store_atomic_null_value(ptr addrspace(200) %ptr) #0 {
; CHECK-LABEL: store_atomic_null_value:
; CHECK:       # %bb.0:
; CHECK-NEXT:    sync
; CHECK-NEXT:    csc $cnull, $zero, 0($c3)
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
  store atomic ptr addrspace(200) null, ptr addrspace(200) %ptr seq_cst, align 32
  ret void
}

; Function Attrs: nounwind
define ptr addrspace(200) @atomic_fetch_swap_null_value(ptr addrspace(200) %ptr) #0 {
; CHECK-LABEL: atomic_fetch_swap_null_value:
; CHECK:       # %bb.0:
; CHECK-NEXT:    .insn
; CHECK-NEXT:  .LBB6_1: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c3
; CHECK-NEXT:    cscc $1, $cnull, $c3
; CHECK-NEXT:    beqz $1, .LBB6_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cmove $c3, $c1
  %t1 = atomicrmw xchg ptr addrspace(200) %ptr, ptr addrspace(200) null acquire
  ret ptr addrspace(200) %t1
}

; Function Attrs: nounwind
define ptr addrspace(200) @atomic_fetch_swap_null_ptr(ptr addrspace(200) %value) #0 {
; CHECK-LABEL: atomic_fetch_swap_null_ptr:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cgetnull $c2
; CHECK-NEXT:  .LBB7_1: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c2
; CHECK-NEXT:    cscc $1, $c3, $c2
; CHECK-NEXT:    beqz $1, .LBB7_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cmove $c3, $c1
  %t1 = atomicrmw xchg ptr addrspace(200) null, ptr addrspace(200) %value acquire
  ret ptr addrspace(200) %t1
}

attributes #0 = { nounwind }
