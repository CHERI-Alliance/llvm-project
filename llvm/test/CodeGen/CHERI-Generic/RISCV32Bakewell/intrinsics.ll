; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/intrinsics.ll
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+zcheripurecap,+cap-mode,+f %s -o - < %s | FileCheck %s --check-prefix=PURECAP
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi ilp32f -mattr=+zcheripurecap,+zcherihybrid,+f -o - < %s | FileCheck %s --check-prefix=HYBRID
; Check that the target-independent CHERI intrinsics are support for all architectures
; The grouping/ordering in this test is based on the RISC-V instruction listing
; in the CHERI ISA specification (Appendix C.1 in ISAv7).
; Capability-Inspection Instructions
declare i32 @llvm.cheri.cap.perms.get.i32(i8 addrspace(200)*)
declare i32 @llvm.cheri.cap.type.get.i32(i8 addrspace(200)*)
declare i32 @llvm.cheri.cap.base.get.i32(i8 addrspace(200)*)
declare i32 @llvm.cheri.cap.length.get.i32(i8 addrspace(200)*)
declare i1 @llvm.cheri.cap.tag.get(i8 addrspace(200)*)
declare i1 @llvm.cheri.cap.sealed.get(i8 addrspace(200)*)
declare i32 @llvm.cheri.cap.offset.get.i32(i8 addrspace(200)*)
declare i32 @llvm.cheri.cap.flags.get.i32(i8 addrspace(200)*)
declare i32 @llvm.cheri.cap.address.get.i32(i8 addrspace(200)*)
declare i32 @llvm.cheri.cap.high.get.i32(i8 addrspace(200)*)
define i32 @perms_get(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: perms_get:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gcperm a0, ca0
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: perms_get:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gcperm a0, ca0
; HYBRID-NEXT:    ret
  %perms = call i32 @llvm.cheri.cap.perms.get.i32(i8 addrspace(200)* %cap)
  ret i32 %perms
}
define i32 @type_get(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: type_get:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gchi a0, ca0
; PURECAP-NEXT:    srli a0, a0, 20
; PURECAP-NEXT:    andi a0, a0, 1
; PURECAP-NEXT:    not a0, a0
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: type_get:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gchi a0, ca0
; HYBRID-NEXT:    srli a0, a0, 20
; HYBRID-NEXT:    andi a0, a0, 1
; HYBRID-NEXT:    not a0, a0
; HYBRID-NEXT:    ret
  %type = call i32 @llvm.cheri.cap.type.get.i32(i8 addrspace(200)* %cap)
  ret i32 %type
}
define i32 @base_get(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: base_get:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gcbase a0, ca0
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: base_get:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gcbase a0, ca0
; HYBRID-NEXT:    ret
  %base = call i32 @llvm.cheri.cap.base.get.i32(i8 addrspace(200)* %cap)
  ret i32 %base
}
define i32 @length_get(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: length_get:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gclen a0, ca0
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: length_get:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gclen a0, ca0
; HYBRID-NEXT:    ret
  %length = call i32 @llvm.cheri.cap.length.get.i32(i8 addrspace(200)* %cap)
  ret i32 %length
}
define i32 @tag_get(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: tag_get:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gctag a0, ca0
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: tag_get:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gctag a0, ca0
; HYBRID-NEXT:    ret
  %tag = call i1 @llvm.cheri.cap.tag.get(i8 addrspace(200)* %cap)
  %tag.zext = zext i1 %tag to i32
  ret i32 %tag.zext
}
define i32 @sealed_get(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: sealed_get:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gchi a0, ca0
; PURECAP-NEXT:    srli a0, a0, 20
; PURECAP-NEXT:    andi a0, a0, 1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: sealed_get:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gchi a0, ca0
; HYBRID-NEXT:    srli a0, a0, 20
; HYBRID-NEXT:    andi a0, a0, 1
; HYBRID-NEXT:    ret
  %sealed = call i1 @llvm.cheri.cap.sealed.get(i8 addrspace(200)* %cap)
  %sealed.zext = zext i1 %sealed to i32
  ret i32 %sealed.zext
}
define i32 @offset_get(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: offset_get:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gcbase a1, ca0
; PURECAP-NEXT:    sub a0, a0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: offset_get:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gcbase a1, ca0
; HYBRID-NEXT:    sub a0, a0, a1
; HYBRID-NEXT:    ret
  %offset = call i32 @llvm.cheri.cap.offset.get.i32(i8 addrspace(200)* %cap)
  ret i32 %offset
}
define i32 @flags_get(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: flags_get:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gchi a0, ca0
; PURECAP-NEXT:    srli a0, a0, 25
; PURECAP-NEXT:    andi a0, a0, 1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: flags_get:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gchi a0, ca0
; HYBRID-NEXT:    srli a0, a0, 25
; HYBRID-NEXT:    andi a0, a0, 1
; HYBRID-NEXT:    ret
  %flags = call i32 @llvm.cheri.cap.flags.get.i32(i8 addrspace(200)* %cap)
  ret i32 %flags
}
define i32 @address_get(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: address_get:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    mv a0, a0
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: address_get:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    mv a0, a0
; HYBRID-NEXT:    ret
  %address = call i32 @llvm.cheri.cap.address.get.i32(i8 addrspace(200)* %cap)
  ret i32 %address
}
define i32 @high_get(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: high_get:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gchi a0, ca0
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: high_get:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gchi a0, ca0
; HYBRID-NEXT:    ret
  %high = call i32 @llvm.cheri.cap.high.get.i32(i8 addrspace(200)* %cap)
  ret i32 %high
}
; Capability-Modification Instructions
declare i8 addrspace(200)* @llvm.cheri.cap.seal(i8 addrspace(200)*, i8 addrspace(200)*)
declare i8 addrspace(200)* @llvm.cheri.cap.unseal(i8 addrspace(200)*, i8 addrspace(200)*)
declare i8 addrspace(200)* @llvm.cheri.cap.perms.and.i32(i8 addrspace(200)*, i32)
declare i8 addrspace(200)* @llvm.cheri.cap.flags.set.i32(i8 addrspace(200)*, i32)
declare i8 addrspace(200)* @llvm.cheri.cap.offset.set.i32(i8 addrspace(200)*, i32)
declare i8 addrspace(200)* @llvm.cheri.cap.address.set.i32(i8 addrspace(200)*, i32)
declare i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i32(i8 addrspace(200)*, i32)
declare i8 addrspace(200)* @llvm.cheri.cap.bounds.set.exact.i32(i8 addrspace(200)*, i32)
declare i8 addrspace(200)* @llvm.cheri.cap.high.set.i32(i8 addrspace(200)*, i32)
declare i8 addrspace(200)* @llvm.cheri.cap.tag.clear(i8 addrspace(200)*)
declare i8 addrspace(200)* @llvm.cheri.cap.build(i8 addrspace(200)*, i8 addrspace(200)*)
declare i8 addrspace(200)* @llvm.cheri.cap.type.copy(i8 addrspace(200)*, i8 addrspace(200)*)
declare i8 addrspace(200)* @llvm.cheri.cap.conditional.seal(i8 addrspace(200)*, i8 addrspace(200)*)
declare i8 addrspace(200)* @llvm.cheri.cap.seal.entry(i8 addrspace(200)*)
define i8 addrspace(200)* @perms_and(i8 addrspace(200)* %cap, i32 %perms) nounwind {
; PURECAP-LABEL: perms_and:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    acperm ca0, ca0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: perms_and:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    acperm ca0, ca0, a1
; HYBRID-NEXT:    ret
  %newcap = call i8 addrspace(200)* @llvm.cheri.cap.perms.and.i32(i8 addrspace(200)* %cap, i32 %perms)
  ret i8 addrspace(200)* %newcap
}
define i8 addrspace(200)* @flags_set(i8 addrspace(200)* %cap, i32 %flags) nounwind {
; PURECAP-LABEL: flags_set:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    lui a2, 1040384
; PURECAP-NEXT:    addi a2, a2, -1
; PURECAP-NEXT:    gchi a3, ca0
; PURECAP-NEXT:    and a2, a3, a2
; PURECAP-NEXT:    andi a1, a1, 1
; PURECAP-NEXT:    slli a1, a1, 25
; PURECAP-NEXT:    or a1, a2, a1
; PURECAP-NEXT:    schi ca0, ca0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: flags_set:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    scmode ca0, ca0, a1
; HYBRID-NEXT:    ret
  %newcap = call i8 addrspace(200)* @llvm.cheri.cap.flags.set.i32(i8 addrspace(200)* %cap, i32 %flags)
  ret i8 addrspace(200)* %newcap
}
define i8 addrspace(200)* @offset_set(i8 addrspace(200)* %cap, i32 %offset) nounwind {
; PURECAP-LABEL: offset_set:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gcbase a2, ca0
; PURECAP-NEXT:    scaddr ca0, ca0, a2
; PURECAP-NEXT:    cadd ca0, ca0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: offset_set:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gcbase a2, ca0
; HYBRID-NEXT:    scaddr ca0, ca0, a2
; HYBRID-NEXT:    cadd ca0, ca0, a1
; HYBRID-NEXT:    ret
  %newcap = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i32(i8 addrspace(200)* %cap, i32 %offset)
  ret i8 addrspace(200)* %newcap
}
define i8 addrspace(200)* @address_set(i8 addrspace(200)* %cap, i32 %address) nounwind {
; PURECAP-LABEL: address_set:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    scaddr ca0, ca0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: address_set:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    scaddr ca0, ca0, a1
; HYBRID-NEXT:    ret
  %newcap = call i8 addrspace(200)* @llvm.cheri.cap.address.set.i32(i8 addrspace(200)* %cap, i32 %address)
  ret i8 addrspace(200)* %newcap
}
define i8 addrspace(200)* @bounds_set(i8 addrspace(200)* %cap, i32 %bounds) nounwind {
; PURECAP-LABEL: bounds_set:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    scbndsr ca0, ca0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: bounds_set:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    scbndsr ca0, ca0, a1
; HYBRID-NEXT:    ret
  %newcap = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i32(i8 addrspace(200)* %cap, i32 %bounds)
  ret i8 addrspace(200)* %newcap
}
define i8 addrspace(200)* @bounds_set_exact(i8 addrspace(200)* %cap, i32 %bounds) nounwind {
; PURECAP-LABEL: bounds_set_exact:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    scbnds ca0, ca0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: bounds_set_exact:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    scbnds ca0, ca0, a1
; HYBRID-NEXT:    ret
  %newcap = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.exact.i32(i8 addrspace(200)* %cap, i32 %bounds)
  ret i8 addrspace(200)* %newcap
}
define i8 addrspace(200)* @high_set(i8 addrspace(200)* %cap, i32 %high) nounwind {
; PURECAP-LABEL: high_set:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    schi ca0, ca0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: high_set:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    schi ca0, ca0, a1
; HYBRID-NEXT:    ret
  %newcap = call i8 addrspace(200)* @llvm.cheri.cap.high.set.i32(i8 addrspace(200)* %cap, i32 %high)
  ret i8 addrspace(200)* %newcap
}
define i8 addrspace(200)* @bounds_set_immediate(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: bounds_set_immediate:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    li a1, 42
; PURECAP-NEXT:    scbndsr ca0, ca0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: bounds_set_immediate:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    li a1, 42
; HYBRID-NEXT:    scbndsr ca0, ca0, a1
; HYBRID-NEXT:    ret
  %newcap = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i32(i8 addrspace(200)* %cap, i32 42)
  ret i8 addrspace(200)* %newcap
}
define i8 addrspace(200)* @build(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2) nounwind {
; PURECAP-LABEL: build:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cbld ca0, ca0, ca1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: build:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cbld ca0, ca0, ca1
; HYBRID-NEXT:    ret
  %built = call i8 addrspace(200)* @llvm.cheri.cap.build(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2)
  ret i8 addrspace(200)* %built
}
define i8 addrspace(200)* @seal_entry(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: seal_entry:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    sentry ca0, ca0
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: seal_entry:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    sentry ca0, ca0
; HYBRID-NEXT:    ret
  %newcap = call i8 addrspace(200)* @llvm.cheri.cap.seal.entry(i8 addrspace(200)* %cap)
  ret i8 addrspace(200)* %newcap
}
; Pointer-Arithmetic Instructions
declare i32 @llvm.cheri.cap.to.pointer(i8 addrspace(200)*, i8 addrspace(200)*)
declare i8 addrspace(200)* @llvm.cheri.cap.from.pointer(i8 addrspace(200)*, i32)
declare i32 @llvm.cheri.cap.diff(i8 addrspace(200)*, i8 addrspace(200)*)
declare i8 addrspace(200)* @llvm.cheri.ddc.get()
declare i8 addrspace(200)* @llvm.cheri.pcc.get()
define i32 @to_pointer(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2) nounwind {
; PURECAP-LABEL: to_pointer:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    gctag a0, ca1
; PURECAP-NEXT:    neg a0, a0
; PURECAP-NEXT:    and a0, a1, a0
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: to_pointer:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    gctag a0, ca1
; HYBRID-NEXT:    neg a0, a0
; HYBRID-NEXT:    and a0, a1, a0
; HYBRID-NEXT:    ret
  %ptr = call i32 @llvm.cheri.cap.to.pointer(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2)
  ret i32 %ptr
}
define i8 addrspace(200)* @from_pointer(i8 addrspace(200)* %cap, i32 %ptr) nounwind {
; PURECAP-LABEL: from_pointer:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    bnez a1, .LBB21_2
; PURECAP-NEXT:  # %bb.1:
; PURECAP-NEXT:    cmv ca0, cnull
; PURECAP-NEXT:    ret
; PURECAP-NEXT:  .LBB21_2:
; PURECAP-NEXT:    scaddr ca0, ca0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: from_pointer:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    bnez a1, .LBB21_2
; HYBRID-NEXT:  # %bb.1:
; HYBRID-NEXT:    cmv ca0, cnull
; HYBRID-NEXT:    ret
; HYBRID-NEXT:  .LBB21_2:
; HYBRID-NEXT:    scaddr ca0, ca0, a1
; HYBRID-NEXT:    ret
  %newcap = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer(i8 addrspace(200)* %cap, i32 %ptr)
  ret i8 addrspace(200)* %newcap
}
define i32 @diff(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2) nounwind {
; PURECAP-LABEL: diff:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    sub a0, a0, a1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: diff:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    sub a0, a0, a1
; HYBRID-NEXT:    ret
  %diff = call i32 @llvm.cheri.cap.diff(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2)
  ret i32 %diff
}
; Assertion Instructions
declare i1 @llvm.cheri.cap.subset.test(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2)
define i32 @subset_test(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2) nounwind {
; PURECAP-LABEL: subset_test:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    scss a0, ca0, ca1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: subset_test:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    scss a0, ca0, ca1
; HYBRID-NEXT:    ret
  %subset = call i1 @llvm.cheri.cap.subset.test(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2)
  %subset.zext = zext i1 %subset to i32
  ret i32 %subset.zext
}
declare i1 @llvm.cheri.cap.equal.exact(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2)
define i32 @equal_exact(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2) nounwind {
; PURECAP-LABEL: equal_exact:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    sceq a0, ca0, ca1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: equal_exact:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    sceq a0, ca0, ca1
; HYBRID-NEXT:    ret
  %eqex = call i1 @llvm.cheri.cap.equal.exact(i8 addrspace(200)* %cap1, i8 addrspace(200)* %cap2)
  %eqex.zext = zext i1 %eqex to i32
  ret i32 %eqex.zext
}
