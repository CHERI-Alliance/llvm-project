// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// Re-enable this test once CHERI-390 is completed.
// UNSUPPORTED: true
// REQUIRES: riscv-registered-target
// Check that we can convert function pointers to PCC-relative capabilities

// RUN: %riscv64_bakewell_hybrid_cc1 -o - -emit-llvm %s | FileCheck %s
// RUN: %riscv64_bakewell_hybrid_cc1 -o - -S %s | FileCheck %s --check-prefixes=ASM-RISCV

void external_fn(void);
int external_global;

// CHECK-LABEL: define {{[^@]+}}@global_fn_to_cap
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.pcc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) [[TMP0]], i64 ptrtoint (ptr @external_fn to i64))
// CHECK-NEXT:    ret ptr addrspace(200) [[TMP1]]
//
void *__capability global_fn_to_cap(void){
// ASM-RISCV-LABEL: global_fn_to_cap:
// ASM-RISCV  addi sp, sp, -32
// ASM-RISCV: cspecialr ca1, pcc
// ASM-RISCV-LABEL: .LBB0_3:
// ASM-RISCV: auipc   a0, %got_pcrel_hi(external_fn)
// ASM-RISCV: ld      a0, %pcrel_lo(.LBB0_3)(a0)
// ASM-RISCV: scaddr  ca2, ca1, a0
// ASM-RISCV: cmv     ca1, cnull
// ASM-RISCV: sc      ca1, 0(sp)                      # 16-byte Folded Spill
// ASM-RISCV: li      a1, 0
// ASM-RISCV: sc      ca2, 16(sp)                     # 16-byte Folded Spill
// ASM-RISCV: bne     a0, a1, .LBB0_2
// ASM-RISCV: lc      ca0, 0(sp)                      # 16-byte Folded Reload
// ASM-RISCV: sc      ca0, 16(sp)                     # 16-byte Folded Spill
// ASM-RISCV-LABEL:   .LBB0_2:
// ASM-RISCV: lc      ca0, 16(sp)                     # 16-byte Folded Reload
// ASM-RISCV: addi    sp, sp, 32
// ASM-RISCV: ret
  return (__cheri_tocap void *__capability) & external_fn;
}

